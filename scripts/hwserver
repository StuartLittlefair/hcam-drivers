#!/usr/bin/env python
from __future__ import print_function, division, unicode_literals
import Pyro4
from hcam_widgets.globals import Container
from hcam_drivers.config import load_config
from hcam_drivers.hardware import (vacuum, meerstetter, unichiller,
                                   slide, honeywell)
from threading import Lock
try:
    from hcam_drivers.hardware import rack
except ImportError:
    rack = None

"""
Use the multiplex server type. This only allows one connection at any one time.

This is non-optimal from a performance point of view, but means we don't have to
worry about making everything thread-safe just yet.
"""
Pyro4.config.SERVERTYPE = "multiplex"


class HardwareWrapper:
    """
    A basic wrapper class to keep track of hardware connection and track state
    """
    def __init__(self, hw_cls, args, kw_args=None):

        if kw_args is None:
            kw_args = {}

        self.hw_cls = hw_cls
        self.args = args
        self.kw_args = kw_args
        try:
            self.instance = hw_cls(*args, **kw_args)
            self.ok = True
        except Exception:
            self.ok = False

    def reboot(self):
        try:
            self.instance = self.hw_cls(*self.args, **self.kw_args)
            self.ok = True
        except Exception:
            self.ok = False


@Pyro4.behavior(instance_mode='single')
class HardwareProxy:
    """
    A class to manage access to hardware running on HiPERCAM

    Only one instance of this class is ever created. It in turn has delegates
    of all the hardware on HiPERCAM, so there is only one instance on the
    whole system for any single piece of hardware. As long as the hardware code
    is threadsafe, this should all be fine...
    """
    def __init__(self):
        print('creating Hardware proxy (should only happen once)')
        self._lock = Lock()
        self._init_hw()
        self.errored = False

    def _init_hw(self):
        print('initialising devices')
        g = Container()
        g.cpars = dict()
        load_config(g)
        cpars = g.cpars
        with self._lock:
            # make objects for talking to hardware
            self.gauges = [
                HardwareWrapper(vacuum.PDR900, (cpars['termserver_ip'], port)) for port in cpars['vacuum_ports']
            ]
            self.ms = [
                HardwareWrapper(meerstetter.MeerstetterTEC1090, (ip, 50000))
                for ip in cpars['meerstetter_ip']
            ]
            if cpars['telins_name'].lower() == 'wht':
                self.chiller = HardwareWrapper(unichiller.UnichillerMPC,
                                               (cpars['termserver_ip'], cpars['chiller_port']))
            else:
                self.chiller = HardwareWrapper(rack.GTCRackSensor, ())

            self.honey = HardwareWrapper(honeywell.Honeywell, (g.cpars['honeywell_ip'], 502))
            ip, port = cpars['termserver_ip'], cpars['slide_port']
            self.focal_plane_slide = HardwareWrapper(slide.Slide, (None, ip, port))

    @Pyro4.expose
    def lookup_hw(self, device, prop):
        """
        Parses device requested from server and matches to Python object
        """
        try:
            device = device.lower()
            if device.startswith('ccd'):
                ccdnum = int(device[-1])
                if prop == 'flow':
                    return self.honey
                elif prop == 'pressure':
                    return self.gauges[ccdnum-1]
                else:
                    ms1, ms2 = self.ms
                    mapping = {1: ms1, 2: ms1, 3: ms1, 4: ms2, 5: ms2}
                    return mapping[ccdnum]

            elif device in ['rack', 'chiller']:
                return self.chiller

            elif device.startswith('ngc'):
                return self.honey

            elif device.startswith('slide'):
                return self.focal_plane_slide
            else:
                raise KeyError('no such device')
        except Exception as err:
            raise ValueError('hardware lookup failed: ' + str(err))

    @Pyro4.expose
    def lookup_get_method(self, device, prop):
        """
        Looks up appropriate method to call to FIND a property from device
        """
        # lookup table of method, args
        device = device.lower()
        if device.startswith('ngc'):
            if prop != 'flow':
                raise KeyError('no such property')
            else:
                return ('read_pen', ('ngc',))

        if device in ['rack', 'chiller']:
            if prop == 'temperature':
                return 'temperature', None
            else:
                raise KeyError('no such property')

        if device.startswith('ccd'):
            ccdnum = int(device[-1])
            meerstetter_address = 1 + ((ccdnum-1) % 3)
            if prop == 'flow':
                return ('read_pen', ('ccd{:d}'.format(ccdnum),))
            elif prop == 'pressure':
                return 'pressure', None
            elif prop == 'current':
                return 'get_current', (meerstetter_address,)
            elif prop == 'temperature':
                return 'get_ccd_temp', (meerstetter_address,)
            elif prop == 'heatsink':
                return 'get_heatsink_temp', (meerstetter_address,)
            elif prop == 'peltier_status':
                return 'get_status', (meerstetter_address,)
            elif prop == 'setpoint':
                return 'get_setpoint', (meerstetter_address,)
            else:
                raise KeyError('no such property')

        if device.startswith('slide'):
            if prop == 'position':
                return 'report_position', None
            else:
                raise KeyError('no such property')

    @Pyro4.expose
    def lookup_set_method(self, device, prop, value):
        """
        Looks up method to SET a property, or send command to a device
        """
        device = device.lower()
        if device.startswith('ngc'):
            raise ValueError('no settable properties on this device')

        elif device.startswith('slide'):
            if prop == 'position':
                if value is None:
                    raise ValueError('must supply a position for slide')
                return 'move_absolute', (value, 'px')
            if prop in ('home', 'enable', 'disable',
                        'stop', 'reset', 'restore'):
                return prop, None

        elif device.startswith('ccd'):
            ccdnum = int(device[-1])
            meerstetter_address = 1 + ((ccdnum-1) % 3)
            if prop == 'tecreset':
                return 'reset_tec', (meerstetter_address,)
            elif prop == 'setpoint':
                return 'set_ccd_temp', (meerstetter_address, value)
            else:
                raise ValueError('not a settable property')

        else:
            raise KeyError('no settable properties on this device')

    @Pyro4.expose
    def get_value(self, name, prop):
        hw = self.lookup_hw(name, prop)
        meth, args = self.lookup_get_method(name, prop)
        try:
            meth = getattr(hw.instance, meth)
        except Exception:
            raise ValueError('method lookup on device has failed')

        try:
            # if there's an issue, turn it off and back on again
            if not hw.ok:
                hw.reboot()

            if callable(meth):
                if args is not None:
                    value = meth(*args)
                else:
                    value = meth()
            else:
                value = meth
        except Exception as err:
            # This really shouldn't happen. Give HW a kick
            hw.ok = False
            raise RuntimeError('command execution failed: ' + str(err))

        return value

    @Pyro4.expose
    def send_command(self, name, prop, value=None):
        hw = self.lookup_hw(name, prop)
        meth, args = self.lookup_set_method(name, prop, value)
        try:
            meth = getattr(hw, meth)
        except Exception:
            raise ValueError('method lookup on device has failed')

        try:
            # if there's an issue, turn it off and back on again
            if not hw.ok:
                hw.reboot()

            if args is not None:
                value = meth(*args)
            else:
                value = meth()
        except Exception as err:
            # This really shouldn't happen. Give HW a kick
            hw.ok = False
            raise RuntimeError('command execution failed:' + str(err))
        return value


if __name__ == "__main__":
    daemon = Pyro4.Daemon(port=5002)
    uri = daemon.register(HardwareProxy, objectId='hwserver')
    print('HWServer daemon running')
    print('Access hardware at {}'.format(uri))
    daemon.requestLoop()
